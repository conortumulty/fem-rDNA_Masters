###############################################
# LONG-READ ROI WORKFLOW WITH CHECKPOINTS
# - Load reference + reads
# - Reverse-complement reads to match reference orientation
# - Print first 10 bp for each sequence
# - Define ROI: reference by coordinates; reads by motifs (normal complements)
# - Checkpoints (A–D)
# - Align read ROIs to ref ROI, call deletions, summarise, plot, export
###############################################

library(Biostrings)
library(IRanges)
library(ggplot2)
library(dplyr)
library(stringr)
library(purrr)
library(tidyr)

base_dir <- "~/Desktop/Nano009_08.fasta"
setwd("~/Desktop/Nano009_08.fasta")

# ================== SET THESE ==================
ref_fa   <- "~/Desktop/Nano009_08.fasta/M45S_wide_range_ANNO.fasta"          
reads_fa <- "~/Desktop/Nano009_08.fasta/83 documents from Nano009_08.fastq.RC.txt.fasta"

# ROI on the reference (1-based, inclusive)
roi_start <- 3280
roi_end   <- 3600

# Motifs in their NORMAL (non-RC) complements:
# 5′ LEFT motif (upstream)
left_motif  <- "AGGCTTAGTTGTTGGGCTTGT"
# 3′ RIGHT motif (downstream)
right_motif <- "TGGTTATCGCTGACCTGCCGTCGAGGTTTC"

# Tuning
max_mismatch_reads <- 3
gap_open <- 8
gap_ext  <- 2
# ================================

# Dependencies (loaded once)
suppressPackageStartupMessages({
  library(Biostrings)
  library(IRanges)
  library(dplyr)
  library(ggplot2)
  library(purrr)
  library(tidyr)
})

# ---------- 1) Load sequences ----------
ref <- readDNAStringSet(ref_fa); stopifnot(length(ref) == 1)
ref_seq <- ref[[1]]
reads <- readDNAStringSet(reads_fa)

# Reverse-complement all reads to match reference orientation
reads <- reverseComplement(reads)
# ---- Assign names by read length order ----
# Get lengths of original reads
read_lengths <- width(reads)

# ---- Assign read names by length with extended alphabet (a..z, aa..az, ba...) ----

# helper: 1 -> "a", 26 -> "z", 27 -> "aa", 52 -> "az", 53 -> "ba", etc.
make_suffix <- function(n) {
  to_alpha <- function(x) {
    s <- ""
    while (x > 0) {
      x <- x - 1
      s <- paste0(letters[(x %% 26) + 1], s)
      x <- x %/% 26
    }
    s
  }
  vapply(seq_len(n), to_alpha, character(1))
}

# order reads by decreasing length
read_lengths <- width(reads)
order_idx <- order(read_lengths, decreasing = TRUE)
reads <- reads[order_idx]
read_lengths <- read_lengths[order_idx]

# assign Nano009_01a, Nano009_01b, ... Nano009_01z, Nano009_01aa, ...
suffixes <- make_suffix(length(reads))
names(reads) <- paste0("Nano009_08", suffixes)

# preview the first few
cat("Renamed reads by length (top 10):\n")
print(data.frame(read_id = names(reads)[1:min(10,length(reads))],
                 length_bp = read_lengths[1:min(10,length(reads))]))


# Make sure read_rois etc inherit the same order
cat("Assigned new names by length:\n")
print(data.frame(read_id = names(reads), length = read_lengths[order_idx])[1:10, ])

cat("✅ Reads have been reverse-complemented to match reference orientation.\n")

cat("✅ Loaded reference & reads\n")
cat("Reference records:", length(ref), " | length:", length(ref_seq), "bp\n")
cat("Read records:", length(reads), "\n\n")

# ---------- 2) Print first 10 bp for each sequence ----------
cat("Reference (", names(ref)[1], ") first 10 bp:\n",
    as.character(subseq(ref_seq, 1, min(10, length(ref_seq)))), "\n\n", sep = "")

cat("Reads: first 10 bp for each sequence\n")
for (i in seq_along(reads)) {
  nm <- if (!is.null(names(reads)) && nzchar(names(reads)[i])) names(reads)[i] else paste0("read_", i)
  seq10 <- as.character(subseq(reads[[i]], 1, min(10, length(reads[[i]]))))
  cat(sprintf("  %s : %s\n", nm, seq10))
}
cat("\n")

# ---------- 3) Define ROIs ----------
# 3A) Reference ROI (by coordinates)
stopifnot(roi_start >= 1, roi_end <= length(ref_seq), roi_start < roi_end)
ref_roi <- subseq(ref_seq, start = roi_start, end = roi_end)
cat("Reference ROI coords: ", roi_start, "-", roi_end, " (", length(ref_roi), " bp)\n\n", sep = "")

# Helpers to find motifs and extract ROI from reads (between LEFT and RIGHT motifs)
find_two_motifs_on_subject <- function(subject_dna, left_pat, right_pat, maxmm = 0) {
  # + strand
  lh <- matchPattern(left_pat,  subject_dna, max.mismatch = maxmm)
  rh <- matchPattern(right_pat, subject_dna, max.mismatch = maxmm)
  if (length(lh) >= 1 && length(rh) >= 1) {
    pairs <- expand.grid(i = seq_along(lh), j = seq_along(rh))
    pairs <- pairs[end(lh)[pairs$i] < start(rh)[pairs$j], , drop = FALSE]
    if (nrow(pairs)) {
      k <- which.min(start(rh)[pairs$j] - end(lh)[pairs$i])
      return(list(strand = "+",
                  left_end = end(lh)[pairs$i[k]],
                  right_start = start(rh)[pairs$j[k]]))
    }
  }
  # - strand (search on RC, then map back)
  subj_rc <- reverseComplement(subject_dna)
  lh_rc <- matchPattern(left_pat,  subj_rc, max.mismatch = maxmm)
  rh_rc <- matchPattern(right_pat, subj_rc, max.mismatch = maxmm)
  if (length(lh_rc) >= 1 && length(rh_rc) >= 1) {
    pairs <- expand.grid(i = seq_along(lh_rc), j = seq_along(rh_rc))
    pairs <- pairs[end(lh_rc)[pairs$i] < start(rh_rc)[pairs$j], , drop = FALSE]
    if (nrow(pairs)) {
      k <- which.min(start(rh_rc)[pairs$j] - end(lh_rc)[pairs$i])
      L <- length(subject_dna)
      left_end_pos    <- L - start(lh_rc)[pairs$i[k]] + 1
      right_start_pos <- L - end(rh_rc)[pairs$j[k]] + 1
      return(list(strand = "-", left_end = left_end_pos, right_start = right_start_pos))
    }
  }
  NULL
}

extract_roi_from_read <- function(read_dna, left_pat, right_pat, maxmm = 2) {
  hit <- find_two_motifs_on_subject(read_dna, left_pat, right_pat, maxmm)
  if (is.null(hit)) return(NULL)
  if (hit$left_end + 1L >= hit$right_start - 1L) return(DNAString(""))  # empty edge case
  if (hit$strand == "+") {
    subseq(read_dna, start = hit$left_end + 1L, end = hit$right_start - 1L)
  } else {
    rdrc <- reverseComplement(read_dna)
    subseq(rdrc,
           start = (length(read_dna) - hit$right_start + 2L),
           end   = (length(read_dna) - hit$left_end))
  }
}

# 3B) Reads ROI (by motifs; per-read)
read_roi_list <- lapply(reads, extract_roi_from_read,
                        left_pat = left_motif, right_pat = right_motif,
                        maxmm = max_mismatch_reads)
ok_idx <- which(!vapply(read_roi_list, is.null, logical(1)))
read_rois <- if (length(ok_idx)) DNAStringSet(read_roi_list[ok_idx]) else DNAStringSet()
names(read_rois) <- if (!is.null(names(reads)) && any(nzchar(names(reads))))
  names(reads)[ok_idx] else paste0("read_", ok_idx)

# ========== CHECKPOINT A: ROI previews ==========
cat("\n--- CHECKPOINT A: ROI previews ---\n")
cat("Reference ROI (first 20 bp): ",
    as.character(subseq(ref_roi, 1, min(20, length(ref_roi)))), "\n")
cat("Reference ROI length: ", length(ref_roi), " bp\n")

n_reads_total <- length(reads)
n_reads_roi   <- length(read_rois)
cat("Reads with ROI found: ", n_reads_roi, "/", n_reads_total, "\n")

if (n_reads_roi > 0) {
  show_n <- min(3, n_reads_roi)
  cat("First ", show_n, " read ROI previews:\n", sep = "")
  for (i in seq_len(show_n)) {
    nm  <- names(read_rois)[i]
    len <- length(read_rois[[i]])
    p20 <- as.character(subseq(read_rois[[i]], 1, min(20, len)))
    cat(sprintf("  %s : len=%d bp | first20=%s\n", nm, len, p20))
  }
}

# ========== CHECKPOINT B: motif hits per read ==========
cat("\n--- CHECKPOINT B: motif hits per read ---\n")
motif_hits <- lapply(seq_along(reads), function(i) {
  hit <- find_two_motifs_on_subject(reads[[i]], left_motif, right_motif, maxmm = max_mismatch_reads)
  if (is.null(hit)) return(NULL)
  data.frame(
    read_id     = ifelse(!is.null(names(reads)[i]) && nzchar(names(reads)[i]),
                         names(reads)[i], paste0("read_", i)),
    strand      = hit$strand,
    left_end    = as.integer(hit$left_end),
    right_start = as.integer(hit$right_start),
    roi_len     = pmax(0L, as.integer(hit$right_start - hit$left_end - 1L)),
    stringsAsFactors = FALSE
  )
})
motif_hits_df <- if (length(na.omit(motif_hits)) == 0) NULL else do.call(rbind, motif_hits)

if (is.null(motif_hits_df)) {
  cat("No reads had both motifs detected.\n")
} else {
  motif_hits_df <- motif_hits_df[order(motif_hits_df$read_id), ]
  print(utils::head(motif_hits_df, 10), row.names = FALSE)
  cat("… (", nrow(motif_hits_df), " reads with both motifs)\n", sep = "")
  cat("ROI length summary (reads):\n")
  print(summary(motif_hits_df$roi_len))
  write.csv(motif_hits_df, "motif_hits_per_read.csv", row.names = FALSE)
  cat("Wrote motif hits table -> motif_hits_per_read.csv\n")
}

# Which reads failed motif detection?
found_ids <- if (!is.null(motif_hits_df)) motif_hits_df$read_id else character(0)
all_ids   <- if (!is.null(names(reads)) && any(nzchar(names(reads))))
  names(reads) else paste0("read_", seq_along(reads))
missing   <- setdiff(all_ids, found_ids)
if (length(missing)) {
  cat("Reads WITHOUT both motifs (skipped):\n  ", paste(missing, collapse = ", "), "\n", sep = "")
}

# ---------- 4) Align each read ROI to the reference ROI and call deletions ----------

# choose the aligner (pwalign if installed, else Biostrings) to avoid warnings
.align_fn <- if (requireNamespace("pwalign", quietly = TRUE)) {
  function(pattern, subject, ...) pwalign::pairwiseAlignment(pattern = pattern, subject = subject, ...)
} else {
  function(pattern, subject, ...) Biostrings::pairwiseAlignment(pattern = pattern, subject = subject, ...)
}

# Scan an alignment and return indels in reference coordinates
# mode = "deletions" -> only deletions in reads (gaps in PATTERN)
# mode = "both"      -> deletions in reads + insertions in reads
call_indels <- function(read_roi, ref_roi, go = 8, ge = 2, mode = c("deletions","both")) {
  mode <- match.arg(mode)
  pa <- .align_fn(pattern = read_roi, subject = ref_roi,
                  type = "global", gapOpening = go, gapExtension = ge)
  
  pat <- as.character(pattern(pa))
  sub <- as.character(subject(pa))
  
  # convert to char vectors once (faster + clearer)
  pv <- strsplit(pat, "", fixed = TRUE)[[1]]
  sv <- strsplit(sub, "", fixed = TRUE)[[1]]
  
  ref_pos <- 0L
  out <- list()
  
  in_del <- FALSE; del_start <- NA_integer_
  in_ins <- FALSE; ins_len   <- 0L; ins_anchor <- NA_integer_
  
  for (i in seq_along(pv)) {
    pg <- pv[i] == "-"   # gap in read (pattern)
    sg <- sv[i] == "-"   # gap in ref  (subject)
    
    # advance reference position when subject is NOT gap
    if (!sg) ref_pos <- ref_pos + 1L
    
    # --- deletions in reads (pattern gap, subject not) ---
    if (pg && !sg) {
      if (!in_del) { in_del <- TRUE; del_start <- ref_pos }
    } else if (in_del) {
      in_del <- FALSE
      out[[length(out) + 1L]] <- data.frame(
        type = "del_in_read",
        ref_start = del_start,
        ref_end   = ref_pos - 1L,
        size      = (ref_pos - 1L) - del_start + 1L,
        stringsAsFactors = FALSE
      )
    }
    
    # --- insertions in reads (subject gap, pattern not) ---
    if (mode == "both") {
      if (sg && !pg) {
        if (!in_ins) { in_ins <- TRUE; ins_len <- 1L; ins_anchor <- ref_pos }
        else ins_len <- ins_len + 1L
      } else if (in_ins) {
        out[[length(out) + 1L]] <- data.frame(
          type = "ins_in_read",
          ref_start = ins_anchor,   # insertion occurs between bases around this ref anchor
          ref_end   = ins_anchor,
          size      = ins_len,
          stringsAsFactors = FALSE
        )
        in_ins <- FALSE; ins_len <- 0L; ins_anchor <- NA_integer_
      }
    }
  }
  # close trailing runs
  if (in_del) {
    out[[length(out) + 1L]] <- data.frame(
      type = "del_in_read", ref_start = del_start, ref_end = ref_pos,
      size = ref_pos - del_start + 1L, stringsAsFactors = FALSE)
  }
  if (mode == "both" && in_ins) {
    out[[length(out) + 1L]] <- data.frame(
      type = "ins_in_read", ref_start = ins_anchor, ref_end = ins_anchor,
      size = ins_len, stringsAsFactors = FALSE)
  }
  
  if (!length(out)) {
    return(tibble::tibble(type = character(0), ref_start = integer(0), ref_end = integer(0), size = integer(0)))
  }
  dplyr::bind_rows(out)
}

# --- run on all read ROIs ---
# Use mode = "deletions" if you only care about deletions in reads; switch to "both" for full picture
indel_list <- purrr::map(read_rois, ~ call_indels(.x, ref_roi, go = gap_open, ge = gap_ext, mode = "deletions"))
names(indel_list) <- names(read_rois)

indel_df <- dplyr::bind_rows(purrr::imap(indel_list, ~ dplyr::mutate(.x, read_id = .y)))

# absolute coordinates on the reference
indel_df <- indel_df %>%
  mutate(ref_abs_start = roi_start + ref_start - 1L,
         ref_abs_end   = roi_start + ref_end   - 1L)

cat("\nTotal deletions detected:", nrow(indel_df), "\n")


# ---- 1) Keep deletions only (skip insertions if present) ----
del_df <- indel_df %>% dplyr::filter(type == "del_in_read")

if (nrow(del_df) == 0) {
  stop("No deletions found in the extracted ROIs. Try mode='both' or adjust ROI/motifs/penalties.")
}

# ---- Recluster deletions + plot reads ordered by original read length ----

# 0) Build a length lookup from the ORIGINAL reads (after reverseComplement + renaming)
length_key <- tibble::tibble(
  read_id      = names(reads),         # e.g., Nano009_01a, Nano009_01b, ...
  read_len_bp  = as.integer(width(reads))
)

# 1) Keep deletions only
del_df <- dplyr::filter(indel_df, type == "del_in_read")
if (nrow(del_df) == 0) stop("No deletions found in the extracted ROIs.")

# 2) Cluster near-identical deletions (unchanged logic)
tolerance <- 3
cluster_key <- function(s, e) paste0(round(s / tolerance), ":", round(e / tolerance))
del_df <- del_df %>% mutate(cluster = cluster_key(ref_abs_start, ref_abs_end))

cluster_summary <- del_df %>%
  group_by(cluster) %>%
  summarise(
    n_reads     = n(),
    approx_start = round(median(ref_abs_start)),
    approx_end   = round(median(ref_abs_end)),
    approx_size  = approx_end - approx_start + 1L,
    .groups = "drop"
  ) %>% arrange(desc(n_reads))
print(cluster_summary)

top_cluster <- cluster_summary$cluster[1]
top_size    <- cluster_summary$approx_size[1]
top_start   <- cluster_summary$approx_start[1]
top_end     <- cluster_summary$approx_end[1]

# Reorder/label using only reads that actually appear in the plot
del_df <- del_df %>% dplyr::left_join(length_key, by = "read_id")

present_ids <- unique(del_df$read_id)
length_key_plot <- length_key %>% dplyr::filter(read_id %in% present_ids)

len_order_present <- length_key_plot %>%
  dplyr::arrange(dplyr::desc(read_len_bp)) %>%
  dplyr::pull(read_id)

del_df$read_id <- factor(del_df$read_id, levels = len_order_present)

# Labels WITHOUT bp lengths
label_map <- setNames(length_key_plot$read_id, length_key_plot$read_id)


# 5) Plot: deletions across reads
p_align <- ggplot(del_df,
                  aes(x = ref_abs_start, xend = ref_abs_end,
                      y = read_id, yend = read_id,
                      colour = (cluster == top_cluster))) +
  geom_segment(linewidth = 2, alpha = 0.95, lineend = "round") +
  scale_colour_manual(values = c(`TRUE` = "red", `FALSE` = "grey70"), guide = "none") +
  scale_y_discrete(labels = label_map, drop = TRUE) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.y = element_text(size = 9, family = "mono"),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  labs(
    title = "Detection of CLass VI Large Deletion in Nano009_08",
    subtitle = paste0("Modal deletion: ", top_size, " bp at ref ", top_start, "–", top_end,
                      " (", sum(del_df$cluster == top_cluster), " segments)"),
    x = paste0("Reference position (bp); ROI ", roi_start, "–", roi_end),
    y = "Individual Nanopore Reads "
  ) +
  annotate("rect", xmin = roi_start, xmax = roi_end,
           ymin = 0.5, ymax = length(levels(del_df$read_id)) + 0.5,
           alpha = 0.04)

print(p_align)
ggsave("read_alignments_shared_deletion.png", p_align, width = 10, height = 8, dpi = 300)


# ---- 5) (Optional) quick sanity text: how many reads carry the modal deletion? ----
reads_with_modal <- del_df %>%
  mutate(has_top = cluster == top_cluster) %>%
  group_by(read_id) %>%
  summarise(has_top = any(has_top), .groups = "drop")

cat("\nReads carrying the modal deletion:", sum(reads_with_modal$has_top), "/", n_distinct(del_df$read_id), "\n")
